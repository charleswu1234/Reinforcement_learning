# -*- coding: utf-8 -*-
"""market_models.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rSYBYqVYslnWyJjtYTsaVT6jwIl-1oIP
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# abstract base class for simulation engine of market models
# requires an instance of MarketModel_Params class as input
# Sim() method is market model dependent and will need to be overrided for each market model
# PlotSim() method plots 100 sample paths with the 10th, 50th, and 90th quantiles overlayed on top
class MarketModel:
  
  def __init__(self, params):
    self.params = params
  
  def Sim(self, sim_params):
    raise Exception("Must be overridden in subclass.")

  def PlotSim(self):
    S, t = self.S, self.t
    Nassets = S.shape[2]
    plt.figure(figsize=(5*Nassets, 5))
    plt.rcParams.update({'font.size': 16})
    plt.rc('axes', labelsize=22)
    for i in range(Nassets):
      plt.subplot(1, Nassets, i+1)
      plt.fill_between(t, np.quantile(S[:,:,i], 0.1, axis=1).T, np.quantile(S[:,:,i], 0.9, axis=1).T, color='y', alpha=0.5)
      # plot first 100 paths
      plt.plot(t, S[:,:100,i], linewidth=0.3)
      # plot first path in a thicker line
      plt.plot(t, S[:,0,i], color='r', linewidth=1.5)
      # plot the 10th, 50th and 90th quantiles
      plt.plot(t, np.quantile(S[:,:,i],[0.1, 0.5, 0.9],axis=1).T, color='k', linewidth=1, linestyle='--')
      plt.xlabel("t")
      plt.ylabel("$S_t^" +str(i+1)+"$")
    
    plt.tight_layout()
    plt.show()

# implementation of one period factor model
class Factor(MarketModel):

  def __init__(self, params = None):
    MarketModel.__init__(self, params)
    self.t = 1
  
  def Sim(self, sim_params):
    _, _, Nsims, Nassets, _, _, _ = sim_params.GetParams()
    # systematic risk factor common to all asset has normal distribution N(0, 0.02)
    sys_risk = np.random.normal(0, 0.02, (Nsims, 1)) 
    # idiosyncratic risk factor for asset i has normal distribution  N(0.03*i, 0.025*i)
    idio_risk = np.zeros((Nsims, Nassets))
    for i in range(1, Nassets + 1):
      idio_risk[:, i - 1] = np.random.normal(0.03 * i, 0.025 * i, Nsims)
    # asset returns are composed of systematic risk factor + idiosyncratic risk factor
    self.S = sys_risk + idio_risk
    # insert time dimension to S for consistency
    self.S = np.expand_dims(self.S, axis=0)

    return self.S

# Implementation of One Asset Ornstein-Uhlenbeck (OU) process
class Ornstein_Uhlenbeck(MarketModel):

  def __init__(self, params):
    MarketModel.__init__(self, params)
  
  def Sim(self, sim_params):
    # load params
    sigma, kappa, theta = self.params.GetParams()
    Ndt, T, Nsims, _, S0, _, _= sim_params.GetParams()
    t = np.linspace(0, T, Ndt+1)
    dt = t[1] - t[0]
    sqrt_dt = np.sqrt(dt)
    Nassets = 1
    # S has dimensions time, number of simulations, number of assets
    S = np.zeros((Ndt + 1, Nsims, Nassets))
    S[0, :, 0] = S0
    # calculate effective volatility 
    sigma_eff = sigma * np.sqrt((1-np.exp(-2*kappa*dt)) / (2*kappa))
    # update risky asset prices
    for i in range(Ndt) : 
      W = np.random.standard_normal((Nsims, Nassets))      
      S[i+1, : , :] =  theta + (S[i, :, :] - theta) * np.exp(-kappa*dt) + sigma_eff * W

    self.t, self.S = t, S
    return t, S